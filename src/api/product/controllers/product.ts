import { factories } from '@strapi/strapi';

type Dict = Record<string, any>;

/* =====================================================
 * HELPERS
 * ===================================================== */

/**
 * Remove fields that are generated by backend logic and must not be
 * overwritten from the admin form.
 *
 * - At product level: uuid, generated_sku, barcode, etc.
 * - At variant level: generated_sku, barcode
 * - At size_stock level: generated_sku, barcode
 */
function lockGeneratedFields(data: Dict) {
  if (!data || typeof data !== 'object') return;

  const LOCK_AT_PRODUCT_LEVEL = [
    'uuid',
    'generated_sku',
    'barcode',
    'factory_batch_code',
    'label_serial_code',
    'tag_serial_code',
    // color_code intentionally NOT locked
  ];

  for (const k of LOCK_AT_PRODUCT_LEVEL) {
    if (Object.prototype.hasOwnProperty.call(data, k)) {
      delete data[k];
    }
  }

  if (Array.isArray(data.product_variants)) {
    data.product_variants = data.product_variants
      .map((raw: Dict) => {
        if (!raw || typeof raw !== 'object') return null;
        const v: Dict = { ...raw };

        // Variant-level auto-generated fields
        if ('generated_sku' in v) delete v.generated_sku;
        if ('barcode' in v) delete v.barcode;

        // Size-level auto-generated fields inside each variant
        if (Array.isArray(v.size_stocks)) {
          v.size_stocks = v.size_stocks
            .map((s: Dict) => {
              if (!s || typeof s !== 'object') return null;
              const size: Dict = { ...s };

              if ('generated_sku' in size) delete size.generated_sku;
              if ('barcode' in size) delete size.barcode;

              return size;
            })
            .filter(Boolean);
        }

        return v;
      })
      .filter(Boolean);
  }
}

/**
 * Normalize a consistent key for a variant's "color identity".
 * Priority: color_code → color_key → color
 */
function normalizeColorKey(v: Dict): string {
  const raw =
    v?.color_code ??
    v?.color_key ??
    v?.color ??
    '';

  const s = String(raw || '').trim();
  if (!s) return '';
  return s.toUpperCase();
}

/**
 * Deduplicate size_stocks for a single variant.
 *
 * - Uses size_name as key
 * - Keeps at most one row per size_name
 * - Prefers row with an existing id (so Strapi updates, not re-creates)
 */
function dedupeSizeStocksForVariant(variant: Dict) {
  if (!variant || typeof variant !== 'object') return;
  if (!Array.isArray(variant.size_stocks)) return;

  const byKey: Record<string, Dict> = {};

  for (const row of variant.size_stocks) {
    if (!row || typeof row !== 'object') continue;

    const sizeName = row.size_name ?? row.size ?? null;
    const key = sizeName ? String(sizeName).trim().toUpperCase() : '';
    if (!key) continue;

    const existing = byKey[key];

    if (!existing) {
      // First time we see this size_name
      byKey[key] = row;
      continue;
    }

    // We already have a row for this size:
    // Prefer the one with an id, so Strapi can track updates properly.
    const existingHasId = !!existing.id;
    const rowHasId = !!row.id;

    if (!existingHasId && rowHasId) {
      byKey[key] = row;
    }
    // else keep existing as-is
  }

  variant.size_stocks = Object.values(byKey);
}

/**
 * Deduplicate product_variants for a product.
 *
 * - One variant per color identity (color_code/color_key/color)
 * - Merges size_stocks across variants of the same color
 * - Variants without any color info are kept as-is and never merged
 */
function dedupeVariants(data: Dict) {
  if (!data || typeof data !== 'object') return;
  if (!Array.isArray(data.product_variants)) return;

  const variants: Dict[] = data.product_variants;

  const byColorKey: Record<string, Dict> = {};
  const variantsWithoutColor: Dict[] = [];

  for (const raw of variants) {
    if (!raw || typeof raw !== 'object') continue;
    const v: Dict = raw;

    // Always dedupe sizes inside each variant first
    dedupeSizeStocksForVariant(v);

    const colorKey = normalizeColorKey(v);

    // If we don't have any usable color identity, keep as-is
    if (!colorKey) {
      variantsWithoutColor.push(v);
      continue;
    }

    const existing = byColorKey[colorKey];

    if (!existing) {
      // First variant we see for this color
      byColorKey[colorKey] = v;
      continue;
    }

    // We already have a variant for this color:
    // Merge size_stocks and metadata instead of discarding one.
    const base = existing;
    const other = v;

    const baseStocks = Array.isArray(base.size_stocks) ? base.size_stocks : [];
    const otherStocks = Array.isArray(other.size_stocks) ? other.size_stocks : [];

    base.size_stocks = [...baseStocks, ...otherStocks];

    // De-duplicate merged size stocks
    dedupeSizeStocksForVariant(base);

    // Prefer IDs / fields from "other" only when base is missing them
    if (!base.id && other.id) base.id = other.id;

    if (!base.color && other.color) base.color = other.color;
    if (!base.color_code && other.color_code) base.color_code = other.color_code;
    if (!base.color_key && other.color_key) base.color_key = other.color_key;

    if (!base.generated_sku && other.generated_sku) base.generated_sku = other.generated_sku;
    if (!base.barcode && other.barcode) base.barcode = other.barcode;

    if (!base.variant_image && other.variant_image) base.variant_image = other.variant_image;
  }

  const dedupedByColor = Object.values(byColorKey);

  data.product_variants = [...variantsWithoutColor, ...dedupedByColor];
}

/**
 * Tiny helpers to normalize relation/media fields to pure ids
 */

function normalizeIdValue(v: any): string | number | null | undefined {
  if (v == null) return v;
  if (typeof v === 'string' || typeof v === 'number') return v;
  if (typeof v === 'object' && 'id' in v && (typeof v.id === 'string' || typeof v.id === 'number')) {
    return v.id;
  }
  return null;
}

function normalizeRelationField(val: any): any {
  if (val == null) return val;

  if (Array.isArray(val)) {
    const ids = val
      .map((item) => normalizeIdValue(item))
      .filter((id) => typeof id === 'string' || typeof id === 'number');
    return ids;
  }

  const id = normalizeIdValue(val);
  if (typeof id === 'string' || typeof id === 'number') {
    return id;
  }

  return null;
}

/**
 * Normalize all relation + media fields for api::product.product
 * so Strapi's updateRelations never sees [object Object] instead of ids.
 */
function normalizeRelationsForWrite(data: Dict, strapi: any) {
  if (!data || typeof data !== 'object') return;

  const contentType = strapi.contentType('api::product.product');
  if (!contentType) return;

  const attrs = contentType.attributes || {};

  for (const [key, attr] of Object.entries<any>(attrs)) {
    if (!Object.prototype.hasOwnProperty.call(data, key)) continue;

    if (attr.type === 'relation' || attr.type === 'media') {
      data[key] = normalizeRelationField(data[key]);
    }
  }

  // Also normalize media inside product_variants component
  if (Array.isArray(data.product_variants)) {
    for (const variant of data.product_variants) {
      if (!variant || typeof variant !== 'object') continue;

      if ('variant_image' in variant) {
        variant.variant_image = normalizeRelationField(variant.variant_image);
      }
    }
  }
}

/**
 * Base populate tree for all "public" reads (REST + custom endpoints).
 * Includes variants + size_stocks + SEO keywords + translations + alt names.
 */
const PUBLIC_POPULATE: Dict = {
  images: true,
  gallery: true,
  product_variants: {
    populate: {
      size_stocks: true,
      variant_image: true,
    },
  },
  seo: {
    populate: {
      keywords: true,
    },
  },
  alt_names_entries: true,
  translations: true,
  categories: true,
  sub_categories: true,
  super_categories: true,
  audience_categories: true,
  age_groups: true,
  gender_groups: true,
  brand_tiers: true,
  events_products_collections: true,
  tags: true,
  reviews: true,
};

/**
 * Merge user-provided populate (from ctx.query.populate) with required PUBLIC_POPULATE.
 * - If populate is a string (e.g. "*"), we ignore and force PUBLIC_POPULATE.
 *
 * NOTE: Return type is `any` on purpose to satisfy Strapi's TS typing for
 * ctx.query.populate (string | string[]), even though at runtime it supports objects.
 */
function mergePopulate(userPopulate: Dict | string | undefined): any {
  if (!userPopulate || typeof userPopulate === 'string') {
    return { ...PUBLIC_POPULATE };
  }

  const up = userPopulate as Dict;

  const merged: Dict = {
    ...up,
    ...PUBLIC_POPULATE,
    product_variants: {
      ...(up.product_variants || {}),
      populate: {
        ...(up.product_variants && up.product_variants.populate
          ? up.product_variants.populate
          : {}),
        ...PUBLIC_POPULATE.product_variants.populate,
      },
    },
    seo: {
      ...(up.seo || {}),
      populate: {
        ...(up.seo && up.seo.populate ? up.seo.populate : {}),
        ...PUBLIC_POPULATE.seo.populate,
      },
    },
  };

  return merged;
}

/* =====================================================
 * CONTROLLER
 * ===================================================== */

export default factories.createCoreController('api::product.product', ({ strapi }) => ({

  /* =====================================================
   * CREATE (admin)
   * ===================================================== */
  async create(ctx) {
    const adminUserId = ctx.state?.user?.id ?? null;

    const body = (ctx.request.body || {}) as Dict;

    // Handle both JSON and multipart: body.data may be JSON string or object
    if (typeof body.data === 'string') {
      try {
        body.data = JSON.parse(body.data);
      } catch (err) {
        strapi.log.warn(
          '[product controller] Failed to parse body.data JSON in create; defaulting to empty object'
        );
        body.data = {};
      }
    }

    body.data = body.data || {};
    const data: Dict = body.data;

    if (adminUserId) {
      data.creator = adminUserId;
      data.last_updated_by = adminUserId;
      if (data.publishedAt) data.verifier = adminUserId;
    }

    // Business rules
    lockGeneratedFields(data);
    dedupeVariants(data);
    normalizeRelationsForWrite(data, strapi);

    body.data = data;
    ctx.request.body = body;

    // @ts-ignore Strapi injects super at runtime
    const result = await super.create(ctx);
    return result;
  },

  /* =====================================================
   * UPDATE (admin)
   * ===================================================== */
  async update(ctx) {
    const adminUserId = ctx.state?.user?.id ?? null;

    const body = (ctx.request.body || {}) as Dict;

    // Handle both JSON and multipart: body.data may be JSON string or object
    if (typeof body.data === 'string') {
      try {
        body.data = JSON.parse(body.data);
      } catch (err) {
        strapi.log.warn(
          '[product controller] Failed to parse body.data JSON in update; defaulting to empty object'
        );
        body.data = {};
      }
    }

    body.data = body.data || {};
    const data: Dict = body.data;

    if (adminUserId) {
      data.last_updated_by = adminUserId;
      if (data.publishedAt) data.verifier = adminUserId;
    }

    // Business rules
    lockGeneratedFields(data);
    dedupeVariants(data);
    normalizeRelationsForWrite(data, strapi);

    body.data = data;
    ctx.request.body = body;

    // @ts-ignore Strapi injects super at runtime
    const result = await super.update(ctx);
    return result;
  },

  /* =====================================================
   * LABEL PDF GENERATOR
   * ===================================================== */
  async labels(ctx) {
    const id = ctx.params.id;

    const entity = await strapi.entityService.findOne('api::product.product', id, {
      populate: {
        product_variants: {
          populate: { size_stocks: true, variant_image: true },
        },
      },
    });

    if (!entity) return ctx.notFound();

    ctx.set('content-type', 'application/pdf');
    ctx.set(
      'content-disposition',
      `inline; filename="labels-${(entity as any).product_code || id}.pdf"`
    );

    const pdf = await strapi.service('api::product.labels').make(entity);
    ctx.body = pdf;
  },

  /* =====================================================
   * DUPLICATE PRODUCT
   * ===================================================== */
  async duplicate(ctx) {
    const id = ctx.params.id;
    const dup = await strapi.service('api::product.duplicate').run(id);
    ctx.body = { id: dup.id };
  },

  /* =====================================================
   * PUBLIC PRODUCT (ID) — custom endpoint
   * ===================================================== */
  async public(ctx) {
    const id = ctx.params.id;

    const entity = await strapi.entityService.findOne('api::product.product', id, {
      populate: PUBLIC_POPULATE,
      publicationState: 'live',
    });

    if (!entity) return ctx.notFound();

    const shaped = await strapi
      .service('api::product.public-shape')
      .serialize(entity, ctx);

    ctx.body = shaped;
  },

  /* =====================================================
   * PUBLIC PRODUCT (SLUG) — custom endpoint
   * ===================================================== */
  async publicBySlug(ctx) {
    const slug = ctx.params.slug;

    const entities = await strapi.entityService.findMany(
      'api::product.product',
      {
        filters: { slug },
        limit: 1,
        publicationState: 'live',
        populate: PUBLIC_POPULATE,
      }
    );

    if (!entities?.[0]) return ctx.notFound();

    const shaped = await strapi
      .service('api::product.public-shape')
      .serialize(entities[0], ctx);

    ctx.body = shaped;
  },

  /* =====================================================
   * PUBLIC LIST — override core find() for /api/products
   * ===================================================== */
  async find(ctx) {
    ctx.query = ctx.query || {};
    // TS types for ctx.query.populate are string | string[], but we intentionally
    // put an object here – Strapi supports this. mergePopulate returns `any`.
    (ctx.query as any).populate = mergePopulate((ctx.query as any).populate);

    // @ts-ignore Strapi injects super at runtime
    const result = await super.find(ctx);
    const data = (result as any).data || [];
    const meta = (result as any).meta;

    const shaper = strapi.service('api::product.public-shape');

    const shaped = await Promise.all(
      data.map((entry: any) =>
        shaper.serialize(
          {
            id: entry.id,
            ...(entry.attributes || {}),
          },
          ctx
        )
      )
    );

    return { data: shaped, meta };
  },

  /* =====================================================
   * PUBLIC SINGLE — override core findOne() for /api/products/:id
   * ===================================================== */
  async findOne(ctx) {
    ctx.query = ctx.query || {};
    (ctx.query as any).populate = mergePopulate((ctx.query as any).populate);

    // @ts-ignore Strapi injects super at runtime
    const result = await super.findOne(ctx);
    const data = (result as any).data;
    const meta = (result as any).meta;

    if (!data) {
      return { data: null, meta };
    }

    const shaper = strapi.service('api::product.public-shape');

    const shaped = await shaper.serialize(
      {
        id: data.id,
        ...(data.attributes || {}),
      },
      ctx
    );

    return { data: shaped, meta };
  },

}));
